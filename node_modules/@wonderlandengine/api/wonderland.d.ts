/**
 * Types
 */
/// <reference types="webxr" />
/**
 * Represents any object that can be used as an array for read / write.
 */
export interface NumberArray {
    length: number;
    [n: number]: number;
}
/**
 * Type to describe a constructor.
 */
export type Constructor<T> = {
    new (...args: any): T;
};
/**
 * Component constructor type.
 */
export type ComponentConstructor<T extends Component> = Constructor<T> & {
    TypeName: string;
    Properties: Record<string, CustomParameter>;
};
/**
 * Component prototype interface.
 *
 * User component's should have the same structure.
 */
export interface ComponentProto {
    /**
     * Triggered after the component instantiation.
     * For more information, please have a look at {@link Component.init}.
     */
    init?: () => void;
    /**
     * Triggered after the component is activated for the first time.
     * For more information, please have a look at {@link Component.start}.
     */
    start?: () => void;
    /**
     * Triggered once per frame.
     * For more information, please have a look at {@link Component.update}.
     *
     * @param dt Delta time, time since last update.
     */
    update?: (dt: number) => void;
    /**
     * Triggered when the component goes from deactivated to activated.
     * For more information, please have a look at {@link Component.onActivate}.
     */
    onActivate?: () => void;
    /**
     * Triggered when the component goes from activated to deactivated.
     * For more information, please have a look at {@link Component.onDeactivate}.
     */
    onDeactivate?: () => void;
    /**
     * Triggered when the component goes from activated to deactivated.
     * For more information, please have a look at {@link Component.onDestroy}.
     */
    onDestroy?: () => void;
}
/**
 * Callback triggered when the session starts.
 *
 * @param session The session that started
 */
export type XrSessionStartCallback = (session: XRSession) => void;
/**
 * Callback triggered for supported / unsupported session.
 *
 * @param type Type of session which is supported/not supported. Either `"vr"` or `"ar"`.
 * @param supported Whether given session type is supported.
 */
export type XrSupportCallback = (type: string, supported: boolean) => void;
/**
 * Callback triggered when the scene is loaded.
 */
export type SceneLoadedCallback = () => void;
export interface GLTFExtensions {
    root: Record<string, any>;
    mesh: Record<string, any>;
    node: Record<string, any>;
    idMapping: Record<string, any>;
}
/**
 * Result obtained when loading a scene.
 */
export type SceneAppendResult = $Object | {
    root: $Object;
    extensions: Record<string, any>;
};
/**
 * Callback triggered on collision event.
 *
 * @param type Type of the event.
 * @param other Other component that was (un)collided with
 */
export type CollisionCallback = (type: CollisionEventType, other: PhysXComponent) => void;
/**
 * Wonderland Engine API
 * @namespace WL
 */
/**
 * Component parameter type enum
 */
export declare enum Type {
    /**
     * **Bool**:
     *
     * Appears in the editor as checkbox.
     */
    Bool = 2,
    /**
     * **Int**:
     *
     * Appears in the editor as int input field.
     */
    Int = 4,
    /**
     * **Float**:
     *
     * Appears in the editor as float input field.
     */
    Float = 8,
    /**
     * **String / Text**:
     *
     * Appears in the editor as text input field.
     */
    String = 16,
    /**
     * **Enumeration**:
     *
     * Appears in the editor as dropdown with given values.
     * If parameters is enum, a `values` parameter needs to be
     * specified for the parameter as well.
     *
     * @example
     *     camera: {type: Type.Enum, values: ['auto', 'back', 'front'], default: 'auto'},
     */
    Enum = 32,
    /**
     * **Object reference**:
     *
     * Appears in the editor as object resource selection dropdown
     * with object picker.
     */
    Object = 64,
    /**
     * **Mesh reference**:
     *
     * Appears in the editor as mesh resource selection dropdown.
     */
    Mesh = 128,
    /**
     * **Texture reference**:
     *
     * Appears in the editor as texture resource selection dropdown.
     */
    Texture = 256,
    /**
     * **Material reference**:
     *
     * Appears in the editor as material resource selection dropdown.
     */
    Material = 512,
    /**
     * **Animation reference**:
     *
     * Appears in the editor as animation resource selection dropdown.
     */
    Animation = 1024,
    /**
     * **Skin reference**:
     *
     * Appears in the editor as skin resource selection dropdown.
     */
    Skin = 2048
}
/**
 * Custom component parameter.
 *
 * For more information about component properties, have a look
 * at the {@link Component.Properties} attribute.
 */
export interface CustomParameter {
    /** Parameter type. */
    type: Type;
    /** Default value, depending on type. */
    default?: any;
    /** Values for {@link Type} */
    values?: string[];
}
/**
 * Register a custom JavaScript component type.
 *
 * You can register a component directly using a class inheriting from {@link Component}:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 * registerComponent(class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myParam: {type: Type.Float, default: 42.0},
 *     };
 *     init: function() {},
 *     start: function() {},
 *     update: function(dt) {},
 *     onActivate: function() {},
 *     onDeactivate: function() {},
 *     onDestroy: function() {}
 * });
 * ```
 *
 * Or directly use an object literal as a prototype:
 *
 * ```js
 * registerComponent('my-new-type', {
 *    myParam: {type: Type.Float, default: 42.0},
 * }, {
 *    init: function() {},
 *    start: function() {},
 *    update: function(dt) {},
 *    onActivate: function() {},
 *    onDeactivate: function() {},
 *    onDestroy: function() {},
 * });
 * ```
 *
 * @param name Name of the component or a class extending {@link Component}.
 * @param params Dict of param names to {@link CustomParameter}.
 * @param object Object containing functions for the component type.
 */
declare function registerComponent<T extends Component>(name: string | ComponentConstructor<T>, params?: {
    [key: string]: CustomParameter;
}, object?: ComponentProto): void;
/**
 * Collider type enum for {@link CollisionComponent}.
 */
export declare enum Collider {
    /**
     * **Sphere Collider**:
     *
     * Simplest and most performant collision shape. If this type is set on a
     * {@link CollisionComponent}, only the first component of
     * {@link CollisionComponent#extents} will be used to determine the radius.
     */
    Sphere = 0,
    /**
     * **Axis Aligned Bounding Box Collider**:
     *
     * Box that is always aligned to XYZ axis. It cannot be rotated but is more
     * efficient than {@link Collider.Box}.
     */
    AxisAlignedBox = 1,
    /**
     * **Aligned Bounding Box Collider**:
     *
     * Box that matches the object's rotation and translation correctly. This
     * is the least efficient collider and should only be chosen over
     * {@link Collider.Sphere} and {@link Collider.AxisAlignedBox} if really
     * necessary.
     */
    Box = 2
}
/**
 * Alignment type enum for {@link TextComponent}.
 */
export declare enum Alignment {
    /** Text start is at object origin */
    Left = 1,
    /** Text center is at object origin */
    Center = 2,
    /** Text end is at object origin */
    Right = 3
}
/**
 * Justification type enum for {@link TextComponent}.
 */
export declare enum Justification {
    /** Text line is at object origin */
    Line = 1,
    /** Text middle is at object origin */
    Middle = 2,
    /** Text top is at object origin */
    Top = 3,
    /** Text bottom is at object origin */
    Bottom = 4
}
/**
 * Effect type enum for {@link TextComponent}.
 */
export declare enum TextEffect {
    /** Text is rendered normally */
    None = 0,
    /** Text is rendered with an outline */
    Outline = 1
}
/**
 * Input type enum for {@link InputComponent}.
 */
export declare enum InputType {
    /** Head input */
    Head = 0,
    /** Left eye input */
    EyeLeft = 1,
    /** Right eye input */
    EyeRight = 2,
    /** Left controller input */
    ControllerLeft = 3,
    /** Right controller input */
    ControllerRight = 4,
    /** Left ray input */
    RayLeft = 5,
    /** Right ray input */
    RayRight = 6
}
/**
 * Light type enum for {@link LightComponent}.
 */
export declare enum LightType {
    /** Point light */
    Point = 1,
    /** Spot light */
    Spot = 2,
    /** Sun light / Directional light */
    Sun = 3
}
/**
 * Animation state of {@link AnimationComponent}.
 */
export declare enum AnimationState {
    /** Animation is currently playing */
    Playing = 1,
    /** Animation is paused and will continue at current playback
     * time on {@link AnimationComponent#play} */
    Paused = 2,
    /** Animation is stopped */
    Stopped = 3
}
/**
 * Rigid body force mode for {@link PhysXComponent#addForce} and {@link PhysXComponent#addTorque}.
 *
 * [PhysX API Reference](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/structPxForceMode.html)
 */
export declare enum ForceMode {
    /** Apply as force */
    Force = 0,
    /** Apply as impulse */
    Impulse = 1,
    /** Apply as velocity change, mass dependent */
    VelocityChange = 2,
    /** Apply as mass dependent force */
    Acceleration = 3
}
/**
 * Collision callback event type.
 */
export declare enum CollisionEventType {
    /** Touch/contact detected, collision */
    Touch = 0,
    /** Touch/contact lost, uncollide */
    TouchLost = 1,
    /** Touch/contact with trigger detected */
    TriggerTouch = 2,
    /** Touch/contact with trigger lost */
    TriggerTouchLost = 3
}
/**
 * Rigid body {@link PhysXComponent#shape}.
 *
 * [PhysX SDK Guide](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Geometry.html#geometry-types).
 */
export declare enum Shape {
    /** No shape. */
    None = 0,
    /** Sphere shape. */
    Sphere = 1,
    /** Capsule shape. */
    Capsule = 2,
    /** Box shape. */
    Box = 3,
    /** Plane shape. */
    Plane = 4,
    /** Convex mesh shape. */
    ConvexMesh = 5,
    /** Triangle mesh shape. */
    TriangleMesh = 6
}
/**
 * Mesh attribute enum.
 * @since 0.9.0
 */
export declare enum MeshAttribute {
    /** Position attribute, 3 floats */
    Position = 0,
    /** Tangent attribute, 4 floats */
    Tangent = 1,
    /** Normal attribute, 3 floats */
    Normal = 2,
    /** Texture coordinate attribute, 2 floats */
    TextureCoordinate = 3,
    /** Color attribute, 4 floats, RGBA, range `0` to `1` */
    Color = 4,
    /** Joint id attribute, 4 unsigned ints */
    JointId = 5,
    /** Joint weights attribute, 4 floats */
    JointWeight = 6,
    /** Secondary joint id attribute, 4 unsigned ints */
    SecondaryJointId = 7,
    /** Secondary joint weights attribute, 4 floats */
    SecondaryJointWeight = 8
}
/**
 * Material parameter type.
 */
export declare enum MaterialParamType {
    /** Unsigned integer parameter type. */
    UnsignedInt = 0,
    /** Integer parameter type. */
    Int = 1,
    /** Float parameter type. */
    Float = 2,
    /** Sampler resource parameter type, i.e., a {@link Texture}. */
    Sampler = 3,
    /**
     * Font resource parameter type.
     *
     * **Note**: Changing font isn't exposed yet and will raise an error.
     */
    Font = 4
}
/**
 * Canvas element that Wonderland Engine renders to.
 */
declare let canvas: HTMLCanvasElement | null;
/**
 * Current WebXR session or {@link null} if no session active
 * @type {XRSession}
 */
declare let xrSession: XRSession | null;
/**
 * List of functions to call if a WebXR session is started
 */
declare const onXRSessionStart: XrSessionStartCallback[];
/**
 * List of functions to call if a WebXR session ends
 */
declare const onXRSessionEnd: (() => void)[];
/**
 * Whether AR is supported by the browser
 *
 * `undefined` until support could be determined
 */
declare let arSupported: boolean | undefined;
/**
 * Whether VR is supported by the browser
 *
 * `undefined` until support could be determined
 */
declare let vrSupported: boolean | undefined;
/**
 * List of functions to call once VR/AR support has been determined.
 *
 * Will be called once for AR and once for VR independent of support for each.
 * This allows you to notify the user of both cases: support and missing support of XR.
 * See the `supported` parameter of the callback, which indicates support.
 */
declare let onXRSupported: XrSupportCallback[];
/**
 * List of functions to call once the main scene has been loaded.
 */
declare let onSceneLoaded: SceneLoadedCallback[];
/**
 * Current main scene
 * @type {Scene}
 */
declare let scene: Scene | undefined;
/**
 * Physics, only available when physx is enabled in the runtime
 * @type {Physics}
 */
declare let physics: Physics | undefined;
/**
 * Image cache.
 *
 * @hidden
 */
declare let _images: (HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null)[];
/**
 * List of callbacks triggered when the scene is loaded.
 *
 * @hidden
 */
declare let _sceneLoadedCallback: any[];
/**
 * Initialize API resources, called by the engine automatically.
 *
 * @hidden
 */
declare function init(): void;
/**
 * Reset the runtime state, including:
 *     - Component cache
 *     - Images
 *     - Callbacks
 *
 * **Note**: This is used internally.
 *
 * @hidden
 */
declare function reset(): void;
/**
 * Initialize API resources, called by the engine automatically, if
 * PhysX is enabled.
 *
 * @hidden
 */
declare function _initPhysics(): void;
declare function updateTempMemory(): void;
export { registerComponent, canvas, scene, xrSession, onXRSessionStart, onXRSessionEnd, onXRSupported, onSceneLoaded, arSupported, vrSupported, physics, _images, _sceneLoadedCallback, textures, init, reset, _initPhysics, updateTempMemory, };
/**
 * Provides global scene functionality like raycasting.
 */
export declare class Scene {
    /** Called before rendering the scene */
    onPreRender: (() => void)[];
    /** Called after the scene has been rendered */
    onPostRender: (() => void)[];
    /** Ray hit pointer in WASM heap. @hidden */
    private _rayHit;
    /** Ray hit. @hidden */
    private _hit;
    constructor();
    /**
     * Currently active view components.
     */
    get activeViews(): ViewComponent[];
    /**
     * Cast a ray through the scene and find intersecting objects.
     *
     * The resulting ray hit will contain up to **4** closest ray hits,
     * sorted by increasing distance.
     *
     * @param o Ray origin.
     * @param d Ray direction.
     * @param group Collision group to filter by: only objects that are
     *        part of given group are considered for raycast.
     *
     * @returns The scene cached {@link RayHit} instance.
     * @note The returned object is owned by the Scene instance
     *   will be reused with the next {@link Scene#rayCast} call.
     */
    rayCast(o: number[], d: number[], group: number): RayHit;
    /**
     * Add an object to the scene.
     *
     * @param parent Parent object or {@link null}.
     * @returns A newly created object.
     */
    addObject(parent: $Object | null): $Object;
    /**
     * Batch-add objects to the scene.
     *
     * Will provide better performance for adding multiple objects (e.g. > 16)
     * than calling {@link Scene#addObject} repeatedly in a loop.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * convervatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param count Number of objects to add.
     * @param parent Parent object or {@link null}, default {@link null}.
     * @param componentCountHint Hint for how many components in total will
     *      be added to the created objects afterwards, default `0`.
     * @returns {$Object[]} newly created objects
     */
    addObjects(count: number, parent: $Object | null, componentCountHint: number): $Object[];
    /**
     * Pre-allocate memory for a given amount of objects and components.
     *
     * Will provide better performance for adding objects later with {@link Scene#addObject}
     * and {@link Scene#addObjects}.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * convervatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param objectCount Number of objects to add.
     * @param componentCountPerType Amount of components to
     *      allocate for {@link $Object.addComponent}, e.g. `{mesh: 100, collision: 200, "my-comp": 100}`.
     * @since 0.8.10
     */
    reserveObjects(objectCount: number, componentCountPerType: {
        [key: string]: number;
    }): void;
    /**
     * Set the background clear color.
     *
     * @param color new clear color (RGBA).
     * @since 0.8.5
     */
    set clearColor(color: number[]);
    /**
     * Set whether to clear the color framebuffer before drawing.
     *
     * This function is useful if an external framework (e.g. an AR tracking
     * framework) is responsible for drawing a camera frame before Wonderland
     * Engine draws the scene on top of it.
     *
     * @param b Whether to enable color clear.
     * @since 0.9.4
     */
    set colorClearEnabled(b: boolean);
    /**
     * Load a scene file (.bin)
     *
     * Will replace the currently active scene with the one loaded
     * from given file. It is assumed that JavaScript components required by
     * the new scene were registered in advance.
     *
     * @param filename Path to the .bin file.
     */
    load(filename: string): void;
    /**
     * Load an external 3D file (.gltf, .glb).
     *
     * Loads and parses the gltf file and its images and appends the result
     * to scene.
     *
     * ```js
     * WL.scene.append(filename).then(root => {
     *     // root contains the loaded scene
     * });
     * ```
     *
     * In case the `loadGltfExtensions` option is set to true, the response
     * will be an object containing both the root of the loaded scene and
     * any glTF extensions found on nodes, meshes and the root of the file.
     *
     * ```js
     * WL.scene.append(filename, { loadGltfExtensions: true }).then(({root, extensions}) => {
     *     // root contains the loaded scene
     *     // extensions.root contains any extensions at the root of glTF document
     *     const rootExtensions = extensions.root;
     *     // extensions.mesh and extensions.node contain extensions indexed by Object id
     *     const childObject = root.children[0];
     *     const meshExtensions = root.meshExtensions[childObject.objectId];
     *     const nodeExtensions = root.nodeExtensions[childObject.objectId];
     *     // extensions.idMapping contains a mapping from glTF node index to Object id
     * });
     * ```
     *
     * @param filename Path to the .gltf or .glb file.
     * @param options Additional options for loading.
     * @returns Root of the loaded scene.
     */
    append(filename: string, options: Record<any, string>): Promise<SceneAppendResult>;
    /**
     * Unmarshalls the GltfExtensions from an Uint32Array.
     *
     * @param data Array containing the gltf extension data.
     * @returns The extensions stored in an object literal.
     *
     * @hidden
     */
    _unmarshallGltfExtensions(data: Uint32Array): GLTFExtensions;
    /**
     * Reset the scene.
     *
     * This method deletes all used and allocated objects, and components.
     */
    reset(): void;
}
/**
 * Native component
 *
 * Provides access to a native component instance of a specified component type.
 *
 * Usage example:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 *
 * class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myBoolean: { type: Type.Boolean, default: false },
 *     };
 *     start() {}
 *     onActivate() {}
 *     onDeactivate() {}
 *     update(dt) {}
 * }
 * ```
 */
export declare class Component {
    /**
     * Unique identifier for this component class.
     *
     * This is used to register, add, and retrieve component of a given type.
     */
    static TypeName: string;
    /**
     * Properties of this component class.
     *
     * Properties are public attributes that can be configured via the
     * Wonderland Editor.
     *
     * Example:
     *
     * ```js
     * import { Component, Type } from '@wonderlandengine/api';
     * class MyComponent extends Component {
     *     static TypeName = 'my-component';
     *     static Properties = {
     *         myBoolean: { type: Type.Boolean, default: false },
     *         myFloat: { type: Type.Float, default: false },
     *         myTexture: { type: Type.Texture, default: null },
     *     };
     * }
     * ```
     *
     * Properties are automatically added to each component instance, and are
     * accessible like any JS attribute:
     *
     * ```js
     * // Creates a new component and set each properties value:
     * const myComponent = object.addComponent(MyComponent, {
     *     myBoolean: true,
     *     myFloat: 42.0,
     *     myTexture: null
     * });
     *
     * // You can also override the properties on the instance:
     * myComponent.myBoolean = false;
     * myComponent.myFloat = -42.0;
     * ```
     */
    static Properties: Record<string, CustomParameter>;
    /**
     * Triggered when the component is initialized by the runtime. This method
     * will only be triggered **once** after instantiation.
     */
    init?(): void;
    /**
     * Triggered when the component is started by the runtime, or activated.
     *
     * You can use that to re-initialize the state of the component.
     */
    start?(): void;
    /**
     * Triggered  **every frame** by the runtime.
     *
     * You should perform your business logic in this method. Example:
     *
     * ```js
     * import { Component, Type } from '@wonderlandengine/api';
     *
     * class TranslateForwardComponent extends Component {
     *     static TypeName = 'translate-forward-component';
     *     static Properties = {
     *         speed: { type: Type.Float, default: 1.0 }
     *     };
     *     constructor() {
     *         this._forward = new Float32Array([0, 0, 0]);
     *     }
     *     update(dt) {
     *         this.object.getForward(this._forward);
     *         this._forward[0] *= this.speed;
     *         this._forward[1] *= this.speed;
     *         this._forward[2] *= this.speed;
     *         this.object.translate(this._forward);
     *     }
     * }
     * ```
     *
     * @param delta Elapsed time between this frame and the previous one, in **seconds**.
     */
    update?(delta: number): void;
    /**
     * Triggered when the component goes from an inactive state to an active state.
     *
     * @note You can manually activate or deactivate a component using: {@link Component.activate}.
     */
    onActivate?(): void;
    /**
     * Triggered when the component goes from an activated state to an inactive state.
     *
     * @note You can manually activate or deactivate a component using: {@link Component.activate}.
     */
    onDeactivate?(): void;
    /** Manager index. @hidden */
    protected readonly _manager: number;
    /** Instance index. @hidden */
    protected readonly _id: number;
    /**
     * Object containing this object.
     *
     * **Note**: This is cached for faster retrieval.
     *
     * @hidden
     */
    private _object;
    /**
     * Component's typename, e.g., 'my-component'.
     *
     * @todo: Should be deprecated. Constructor should be looked up instead.
     *
     * @hidden
     */
    private _type;
    /**
     * Create a new instance
     *
     * @param managerIndex Index of the manager.
     * @param id WASM component instance index.
     *
     * @hidden
     */
    constructor(managerIndex?: number, id?: number);
    /** The name of this component's type */
    get type(): string;
    /** The object this component is attached to. */
    get object(): $Object;
    /**
     * Set whether this component is active.
     *
     * Activating/deactivating a component comes at a small cost of reordering
     * components in the respective component manager. This function therefore
     * is not a trivial assignment.
     *
     * Does nothing if the component is already activated/deactivated.
     *
     * @param active New active state.
     */
    set active(active: boolean);
    /**
     * Whether this component is active
     */
    get active(): boolean;
    /**
     * Remove this component from its objects and destroy it.
     *
     * It is best practice to set the component to `null` after,
     * to ensure it does not get used later.
     *
     * ```js
     *    c.destroy();
     *    c = null;
     * ```
     * @since 0.9.0
     */
    destroy(): void;
    /**
     * Checks equality by comparing whether the wrapped native component ids
     * and component manager types are equal.
     *
     * @param otherComponent Component to check equality with.
     * @returns Whether this component equals the given component.
     */
    equals(otherComponent: Component | undefined | null): boolean;
}
/**
 * Native collision component.
 *
 * Provides access to a native collision component instance.
 */
export declare class CollisionComponent extends Component {
    /** Collision component collider */
    get collider(): Collider;
    /**
     * Set collision component collider.
     *
     * @param collider Collider of the collision component.
     */
    set collider(collider: Collider);
    /**
     * Collision component extents.
     *
     * If {@link collider} returns {@link Collider.Sphere}, only the first
     * component of the returned vector is used.
     */
    get extents(): Float32Array;
    /**
     * Set collision component extents.
     *
     * If {@link collider} returns {@link Collider.Sphere}, only the first
     * component of the passed vector is used.
     *
     * Example:
     *
     * ```js
     * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
     * collision.extent = [1, 2, 3];
     * ```
     *
     * @param extents Extents of the collision component, expects a
     *      3 component array.
     */
    set extents(extents: Readonly<NumberArray>);
    /**
     * Collision component group.
     *
     * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
     * or the group in {@link Scene#rayCast}.
     *
     * Colliders that have no common groups will not overlap with each other. If a collider
     * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
     *
     * Each bit represents belonging to a group, see example.
     *
     * ```js
     *    // c belongs to group 2
     *    c.group = (1 << 2);
     *
     *    // c belongs to group 0
     *    c.group = (1 << 0);
     *
     *    // c belongs to group 0 *and* 2
     *    c.group = (1 << 0) | (1 << 2);
     *
     *    (c.group & (1 << 2)) != 0; // true
     *    (c.group & (1 << 7)) != 0; // false
     * ```
     */
    get group(): number;
    /**
     * Set collision component group.
     *
     * @param group Group mask of the collision component.
     */
    set group(group: number);
    /**
     * Query overlapping objects.
     *
     * Usage:
     *
     * ```js
     * const collision = object.getComponent('collision');
     * const overlaps = collision.queryOverlaps();
     * for(const otherCollision of overlaps) {
     *     const otherObject = otherCollision.object;
     *     console.log(`Collision with object ${otherObject.objectId}`);
     * }
     * ```
     *
     * @returns Collision components overlapping this collider.
     */
    queryOverlaps(): CollisionComponent[];
}
/**
 * Native text component
 *
 * Provides access to a native text component instance
 */
export declare class TextComponent extends Component {
    /** Text component alignment. */
    get alignment(): Alignment;
    /**
     * Set text component alignment.
     *
     * @param alignment Alignment for the text component.
     */
    set alignment(alignment: Alignment);
    /** Text component justification. */
    get justification(): Justification;
    /**
     * Set text component justification.
     *
     * @param justification Justification for the text component.
     */
    set justification(justification: Justification);
    /** Text component character spacing. */
    get characterSpacing(): number;
    /**
     * Set text component character spacing.
     *
     * @param spacing Character spacing for the text component.
     */
    set characterSpacing(spacing: number);
    /** Text component line spacing. */
    get lineSpacing(): number;
    /**
     * Set text component line spacing
     *
     * @param spacing Line spacing for the text component
     */
    set lineSpacing(spacing: number);
    /** Text component effect. */
    get effect(): TextEffect;
    /**
     * Set text component effect
     *
     * @param effect Effect for the text component
     */
    set effect(effect: TextEffect);
    /** Text component text. */
    get text(): string;
    /**
     * Set text component text.
     *
     * @param text Text of the text component.
     */
    set text(text: string);
    /**
     * Set material to render the text with.
     *
     * @param material New material.
     */
    set material(material: Material | null | undefined);
    /** Material used to render the text. */
    get material(): Material | null;
}
/**
 * Native view component.
 *
 * Provides access to a native view component instance.
 */
export declare class ViewComponent extends Component {
    /** Projection matrix. */
    get projectionMatrix(): Float32Array;
    /** ViewComponent near clipping plane value. */
    get near(): number;
    /**
     * Set near clipping plane distance for the view.
     *
     * If an XR session is active, the change will apply in the
     * following frame, otherwise the change is immediate.
     *
     * @param near Near depth value.
     */
    set near(near: number);
    /** Far clipping plane value. */
    get far(): number;
    /**
     * Set far clipping plane distance for the view.
     *
     * If an XR session is active, the change will apply in the
     * following frame, otherwise the change is immediate.
     *
     * @param far Near depth value.
     */
    set far(far: number);
    /**
     * Get the horizontal field of view for the view, **in degrees**.
     *
     * If an XR session is active, this returns the field of view reported by
     * the device, regardless of the fov that was set.
     */
    get fov(): number;
    /**
     * Set the horizontal field of view for the view, **in degrees**.
     *
     * If an XR session is active, the field of view reported by the device is
     * used and this value is ignored. After the XR session ends, the new value
     * is applied.
     *
     * @param fov Horizontal field of view, **in degrees**.
     */
    set fov(fov: number);
}
/**
 * Native input component.
 *
 * Provides access to a native input component instance.
 */
export declare class InputComponent extends Component {
    /** Input component type */
    get inputType(): InputType;
    /**
     * Set input component type.
     *
     * @params New input component type.
     */
    set inputType(type: InputType);
    /**
     * WebXR Device API input source associated with this input component,
     * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
     */
    get xrInputSource(): XRInputSource | null;
    /**
     * 'left', 'right' or {@link null} depending on the {@link InputComponent#inputType}.
     */
    get handedness(): 'left' | 'right' | null;
}
/**
 * Native light component.
 *
 * Provides access to a native light component instance.
 */
export declare class LightComponent extends Component {
    /** View on the light color */
    get color(): Float32Array;
    /** Light type. */
    get lightType(): LightType;
    /**
     * Set light type.
     *
     * @param lightType Type of the light component.
     */
    set lightType(t: LightType);
}
/**
 * Native animation component.
 *
 * Provides access to a native animation component instance.
 */
export declare class AnimationComponent extends Component {
    /**
     * Set animation to play.
     *
     * Make sure to {@link Animation#retarget} the animation to affect the
     * right objects.
     *
     * @param anim Animation to play.
     */
    set animation(anim: Animation);
    /** Animation set for this component */
    get animation(): Animation;
    /**
     * Set play count. Set to `0` to loop indefinitely.
     *
     * @param playCount Number of times to repeat the animation.
     */
    set playCount(playCount: number);
    /** Number of times the animation is played. */
    get playCount(): number;
    /**
     * Set speed. Set to negative values to run the animation backwards.
     *
     * Setting speed has an immediate effect for the current frame's update
     * and will continue with the speed from the current point in the animation.
     *
     * @param speed New speed at which to play the animation.
     * @since 0.8.10
     */
    set speed(speed: number);
    /**
     * Speed factor at which the animation is played.
     *
     * @since 0.8.10
     */
    get speed(): number;
    /** Current playing state of the animation */
    get state(): AnimationState;
    /** Play animation. */
    play(): void;
    /** Stop animation. */
    stop(): void;
    /** Pause animation. */
    pause(): void;
}
/**
 * Native mesh component.
 *
 * Provides access to a native mesh component instance.
 */
export declare class MeshComponent extends Component {
    /**
     * Set material to render the mesh with.
     *
     * @param material Material to render the mesh with.
     */
    set material(material: Material | null | undefined);
    /** Material used to render the mesh. */
    get material(): Material | null;
    /** Mesh rendered by this component. */
    get mesh(): Mesh;
    /**
     * Set mesh to rendered with this component.
     *
     * @param mesh Mesh rendered by this component.
     */
    set mesh(mesh: Mesh | null | undefined);
    /** Skin for this mesh component. */
    get skin(): Skin;
    /**
     * Set skin to transform this mesh component.
     *
     * @param {?Skin} skin Skin to use for rendering skinned meshes.
     */
    set skin(skin: Skin);
}
/**
 * Native physx rigid body component.
 *
 * Provides access to a native mesh component instance.
 * Only available when using physx enabled runtime, see "Project Settings > Runtime".
 */
declare class PhysXComponent extends Component {
    /**
     * Set whether this rigid body is static.
     *
     * Setting this property only takes effect once the component
     * switches from inactive to active.
     *
     * @param b Whether the rigid body should be static.
     */
    set static(b: boolean);
    /**
     * Whether this rigid body is static.
     *
     * This property returns whether the rigid body is *effectively*
     * static. If static property was set while the rigid body was
     * active, it will not take effect until the rigid body is set
     * inactive and active again. Until the component is set inactive,
     * this getter will return whether the rigidbody is actually
     * static.
     */
    get static(): boolean;
    /**
     * Set whether this rigid body is kinematic.
     *
     * @param b Whether the rigid body should be kinematic.
     */
    set kinematic(b: boolean);
    /**
     * Whether this rigid body is kinematic.
     */
    get kinematic(): boolean;
    /**
     * Set the shape for collision detection.
     *
     * @param s New shape.
     * @since 0.8.5
     */
    set shape(s: Shape);
    /** The shape for collision detection. */
    get shape(): Shape;
    /**
     * Set additional data for the shape.
     *
     * Retrieved only from {@link PhysXComponent#shapeData}.
     * @since 0.8.10
     */
    set shapeData(d: {
        index: number;
    } | null);
    /**
     * Additional data for the shape.
     *
     * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
     * `{index: n}` for `TriangleMesh` and `ConvexHull`.
     *
     * This data is currently only for passing onto or creating other {@link PhysXComponent}.
     * @since 0.8.10
     */
    get shapeData(): {
        index: number;
    } | null;
    /**
     * Set the shape extents for collision detection.
     *
     * @param e New extents for the shape.
     * @since 0.8.5
     */
    set extents(e: Readonly<NumberArray>);
    /**
     * The shape extents for collision detection.
     */
    get extents(): Float32Array;
    /**
     * Get staticFriction.
     */
    get staticFriction(): number;
    /**
     * Set staticFriction.
     * @param v New staticFriction.
     */
    set staticFriction(v: number);
    /**
     * Get dynamicFriction.
     */
    get dynamicFriction(): number;
    /**
     * Set dynamicFriction
     * @param v New dynamicDamping.
     */
    set dynamicFriction(v: number);
    /**
     * Get bounciness.
     * @since 0.9.0
     */
    get bounciness(): number;
    /**
     * Set bounciness.
     * @param v New bounciness.
     * @since 0.9.0
     */
    set bounciness(v: number);
    /**
     * Get linearDamping/
     */
    get linearDamping(): number;
    /**
     * Set linearDamping.
     * @param v New linearDamping.
     */
    set linearDamping(v: number);
    /** Get angularDamping. */
    get angularDamping(): number;
    /**
     * Set angularDamping.
     * @param v New angularDamping.
     */
    set angularDamping(v: number);
    /**
     * Set linear velocity.
     *
     * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New linear velocity.
     */
    set linearVelocity(v: Readonly<NumberArray>);
    /** Linear velocity or `[0, 0, 0]` if the component is not active. */
    get linearVelocity(): Float32Array;
    /**
     * Set angular velocity
     *
     * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New angular velocity
     */
    set angularVelocity(v: Readonly<NumberArray>);
    /** Angular velocity or `[0, 0, 0]` if the component is not active. */
    get angularVelocity(): Float32Array;
    /**
     * Set mass.
     *
     * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
     *
     * @param m New mass.
     */
    set mass(m: number);
    /** Mass */
    get mass(): number;
    /**
     * Set mass space interia tensor.
     *
     * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
     *
     * Has no effect, if the component is not active.
     *
     * @param v New mass space interatia tensor.
     */
    set massSpaceInteriaTensor(v: Readonly<NumberArray>);
    /**
     * Apply a force.
     *
     * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
     *
     * Has no effect, if the component is not active.
     *
     * @param f Force vector.
     * @param m Force mode, see {@link ForceMode}, default `Force`.
     * @param localForce Whether the force vector is in local space, default `false`.
     * @param p Position to apply force at, default is center of mass.
     * @param local Whether position is in local space, default `false`.
     */
    addForce(f: Readonly<NumberArray>, m?: ForceMode, localForce?: boolean, p?: Readonly<NumberArray>, local?: boolean): void;
    /**
     * Apply torque.
     *
     * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
     *
     * Has no effect, if the component is not active.
     *
     * @param f Force vector.
     * @param m Force mode, see {@link ForceMode}, default `Force`.
     */
    addTorque(f: Readonly<NumberArray>, m?: ForceMode): void;
    /**
     * Add on collision callback.
     *
     * @param callback Function to call when this rigid body (un)collides with any other.
     *
     * ```js
     *  let rigidBody = this.object.getComponent('physx');
     *  rigidBody.onCollision(function(type, other) {
     *      // Ignore uncollides
     *      if(type == CollisionEventType.TouchLost) return;
     *
     *      // Take damage on collision with enemies
     *      if(other.object.name.startsWith('enemy-')) {
     *          this.applyDamage(10);
     *      }
     *  }.bind(this));
     * ```
     *
     * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
     */
    onCollision(callback: CollisionCallback): number;
    /**
     * Add filtered on collision callback.
     *
     * @param otherComp Component for which callbacks will
     *        be triggered. If you pass this component, the method is equivalent to.
     *        {@link PhysXComponent#onCollision}.
     * @param callback Function to call when this rigid body
     *        (un)collides with `otherComp`.
     * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
     */
    onCollisionWith(otherComp: this, callback: CollisionCallback): number;
    /**
     * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
     *
     * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
     * @throws When the callback does not belong to the component.
     * @throws When the callback does not exist.
     */
    removeCollisionCallback(callbackId: number): void;
}
export { PhysXComponent };
/**
 * Access to the physics scene
 */
export declare class Physics {
    /**
     * @hidden
     *
     * **Note**: This is public to emulate a `friend` accessor.
     */
    _callbacks: Record<string, CollisionCallback[]>;
    /** Ray Hit */
    private _rayHit;
    /** Hit. */
    private _hit;
    constructor();
    /**
     * Cast a ray through the physics scene and find intersecting objects.
     *
     * The resulting ray hit will contain **up to 4** closest ray hits,
     * sorted by increasing distance.
     *
     * @param o Ray origin.
     * @param d Ray direction.
     * @param group Collision group to filter by: only objects that are
     *        part of given group are considered for raycast.
     * @param maxDistance Maximum ray distance, default `100.0`.
     *
     * @returns The RayHit instance, belonging to this class.
     *
     * @note The returned {@link RayHit} object is owned by the Physics instance and
     *       will be reused with the next {@link Physics#rayCast} call.
     */
    rayCast(o: Readonly<NumberArray>, d: Readonly<NumberArray>, group: number, maxDistance?: number): RayHit;
    /**
     * Triggered by the WASM runtime.
     *
     * @hidden
     */
    private _callCollisionCallback;
}
/**
 * Mesh index type.
 */
export declare enum MeshIndexType {
    /** Single byte mesh index, range 0-255 */
    UnsignedByte = 1,
    /** Two byte mesh index, range 0-65535 */
    UnsignedShort = 2,
    /** Four byte mesh index, range 0-4294967295 */
    UnsignedInt = 4
}
/**
 * Mesh constructor parameters object.
 *
 * Usage:
 *
 * ```js
 * const mesh = Mesh({vertexCount: 3, indexData: [0, 1, 2]});
 * ```
 */
export interface MeshParameters {
    /** Number of vertices to allocate. */
    vertexCount: number;
    /**
     * Deprecated, use `vertexCount` instead and set data with {@link Mesh#attribute} instead.
     *
     * Interleaved vertex data values. A vertex is a
     *      set of 8 float values:
     *          - 0-2 Position
     *          - 3-5 Normal
     *          - 6-8 Texture Coordinate
     *
     * @deprecated
     */
    vertexData: Float32Array;
    /** Index data values. */
    indexData: Readonly<NumberArray>;
    /** Index type, `null` if not indexed. */
    indexType: MeshIndexType;
    /** `true` if the mesh should be skinned. Defaults to false. */
    skinned: boolean;
}
/**
 * Wrapper around a native mesh data.
 *
 * To modify a mesh, you get access to a {@link MeshAttributeAccessor} that allows you to modify
 * the content of the buffers:
 *
 * Usage:
 *
 * ```js
 * const mesh = new Mesh({vertexCount: 3, indexData: [0, 1, 2] });
 * const positions = mesh.attribute(MeshAttribute.Position);
 * ...
 * ```
 */
export declare class Mesh {
    /**
     * Size of a vertex in float elements.
     * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttributeAccessor}
     */
    static get VERTEX_FLOAT_SIZE(): number;
    /**
     * Size of a vertex in bytes.
     * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttributeAccessor}
     */
    static get VERTEX_SIZE(): number;
    /**
     * Position attribute offsets in float elements.
     * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttribute#Position}
     */
    static get POS(): {
        X: number;
        Y: number;
        Z: number;
    };
    /**
     * Texture coordinate attribute offsets in float elements.
     * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttribute#TextureCoordinate}
     */
    static get TEXCOORD(): {
        U: number;
        V: number;
    };
    /**
     * Normal attribute offsets in float elements.
     * @deprecated Replaced with {@link Mesh#attribute} and {@link MeshAttribute#Normal}
     */
    static get NORMAL(): {
        X: number;
        Y: number;
        Z: number;
    };
    /**
     * Index of the mesh in the manager.
     *
     * @hidden
     */
    _index: number;
    /**
     * Create a new instance.
     *
     * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
     *    For more information, please have a look at the {@link MeshParameters} interface.
     */
    constructor(params: Partial<MeshParameters> | number);
    /**
     * Vertex data (read-only).
     *
     * @deprecated Replaced with {@link attribute}
     */
    get vertexData(): Float32Array;
    /** Number of vertices in this mesh. */
    get vertexCount(): number;
    /** Index data (read-only) or {@link null} if the mesh is not indexed. */
    get indexData(): Uint8Array | Uint16Array | Uint32Array | null;
    /** Updates the bounding sphere to match new vertex positions. */
    update(): void;
    /** @overload */
    getBoundingSphere(): Float32Array;
    /** @overload */
    getBoundingSphere<T extends NumberArray>(out: T): T;
    /**
     * Get an attribute accessor to retrieve or modify data of give attribute.
     *
     * @param attr Attribute to get access to
     * @returns {?MeshAttributeAccessor} attr Attribute to get access to or `null`,
     *      if mesh does not have this attribute.
     *
     * If there are no shaders in the scene that use `TextureCoordinate` for example,
     * no meshes will have the `TextureCoordinate` attribute.
     *
     * For flexible reusable components, take this into account that only `Position`
     * is guaranteed to be present at all time.
     */
    attribute(attr: MeshAttribute): MeshAttributeAccessor | null;
    /**
     * Destroy and free the meshes memory.
     *
     * It is best practice to set the mesh variable to `null` after calling
     * destroy to prevent accidental use:
     *
     * ```js
     *   mesh.destroy();
     *   mesh = null;
     * ```
     *
     * Accessing the mesh after destruction behaves like accessing an empty
     * mesh.
     *
     * @since 0.9.0
     */
    destroy(): void;
}
/**
 * An iterator over a mesh vertex attribute.
 *
 * Usage:
 *
 * ```js
 *   const mesh = this.object.getComponent('mesh').mesh;
 *   const positions = mesh.attribute(WL.MeshAttribute.Position);
 *
 *   const temp = new Float32Array(3);
 *   for(int i = 0; i < positions.length; ++i) {
 *       // pos will reference temp and thereby not allocate additional
 *       // JavaScript garbage, which would cause a perf spike when collected.
 *       const pos = positions.get(i, temp);
 *       // scale position by 2 on X axis only
 *       pos[0] *= 2.0f;
 *       positions.set(i, pos);
 *   }
 * ```
 */
export declare class MeshAttributeAccessor {
    /** Attribute index. @hidden */
    _attribute: number;
    /** Attribute offset. @hidden */
    _offset: number;
    /** Attribute stride. @hidden */
    _stride: number;
    /** Format size native enum. @hidden */
    _formatSize: number;
    /** Number of components per vertex. @hidden */
    _componentCount: number;
    /** Max number of elements. */
    readonly length: number;
    /**
     * Class to instantiate an ArrayBuffer to get/set values.
     */
    private _bufferType;
    /**
     * Function to allocate temporary WASM memory. This is cached to avoid
     * any conditional during get/set.
     */
    private _tempBufferGetter;
    /**
     * Create a new instance.
     *
     * @param type The type of data this accessor is wrapping.
     * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
     *
     * @hidden
     */
    constructor(type?: MeshAttribute);
    /**
     * Create a new TypedArray to hold this attribute values.
     *
     * This method is useful to create a view to hold the data to
     * pass to {@link MeshAttributeAccessor.get} and {@link MeshAttributeAccessor.set}
     *
     * Example:
     *
     * ```js
     * const vertexCount = 4;
     * const positionAttribute = mesh.attribute(MeshAttributes.Position);
     *
     * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
     * const positions = positionAttribute.createArray(vertexCount);
     * ```
     *
     * @param count The number of **vertices** expected.
     * @returns A TypedArray with the appropriate format to access the data
     */
    createArray(count?: number): Float32Array | Uint16Array;
    /** @overload */
    get(index: number): Float32Array | Uint16Array;
    /**
     * Set attribute element.
     *
     * @param i Index
     * @param v Value to set the element to
     *
     * `v.length` needs to be a multiple of the attributes component count, see
     * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
     * filled with the next n attribute elements, which can reduce overhead
     * of this call.
     *
     * @returns Reference to self (for method chaining)
     */
    set(i: number, v: Readonly<NumberArray>): this;
}
/**
 * Constructor parameters object for a {@link Material} instance.
 */
export interface MaterialParameters {
    /** The name of the pipeline. */
    pipeline: string;
}
/**
 * Wrapper around a native material.
 *
 * Each material instance will have properties associated to the pipeline it uses.
 * The material properties are automatically added to each material instance, example:
 *
 * ```js
 * const material = mesh.material; // Material with a `Phong Opaque Textured` pipeline
 * // You can access all the material properties from the editor using:
 * material.diffuseTexture = null;
 * material.diffuseColor = [1.0, 0.0, 0.0, 1.0];
 * ```
 */
export declare class Material {
    /**
     * Index of this material in the manager.
     *
     * @hidden
     */
    _index: number;
    /**
     * Material definition index in the scene.
     *
     * @hidden
     */
    private _definition;
    /**
     * Create a new Material.
     *
     * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
     * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
     */
    constructor(params: number | MaterialParameters);
    /** Name of the shader used by this material. */
    get shader(): string;
    /**
     * Create a copy of the underlying native material.
     *
     * @returns Material clone.
     */
    clone(): Material | null;
    /**
     * Wrap a native material index.
     *
     * @param index The index.
     * @returns Material instance or {@link null} if index <= 0.
     *
     * @deprecated Please use `new Material()` instead.
     */
    static wrap(index: number): Material | null;
}
/**
 * Wrapper around a native texture data.
 */
export declare class Texture {
    /** Index in the manager. @hidden */
    private _id;
    /** HTML image index. @hidden */
    private _imageIndex;
    /**
     * @param param HTML media element to create texture from or texture id to wrap.
     */
    constructor(param: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | number);
    /** Whether this texture is valid. */
    get valid(): boolean;
    /** Index in this manager. */
    get id(): number;
    /** Update the texture to match the HTML element (e.g. reflect the current frame of a video). */
    update(): void;
    /** Width of the texture. */
    get width(): number;
    /** Height of the texture. */
    get height(): number;
    /**
     * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video).
     *
     * Usage:
     *
     * ```js
     * // Copies rectangle of pixel starting from (10, 20)
     * texture.updateSubImage(10, 20, 600, 400);
     * ```
     *
     * @param x x offset
     * @param y y offset
     * @param w width
     * @param h height
     */
    updateSubImage(x: number, y: number, w: number, h: number): void;
    /**
     * Destroy and free the texture's texture altas space and memory.
     *
     * It is best practice to set the texture variable to `null` after calling
     * destroy to prevent accidental use of the invalid texture:
     *
     * ```js
     *   texture.destroy();
     *   texture = null;
     * ```
     *
     * @since 0.9.0
     */
    destroy(): void;
}
export type TextureCache = {
    [key: string]: Texture | ((filename: string, crossOrigin?: string) => Promise<Texture>);
    load: (filename: string, crossOrigin?: string) => Promise<Texture>;
};
/**
 * Access to the textures managed by Wonderland Engine.
 */
declare const textures: TextureCache;
/**
 * Wrapper around a native animation.
 */
export declare class Animation {
    /** Index of the mesh in the manager. @hidden */
    _index: number;
    /**
     * @param index Index in the manager
     */
    constructor(index: number);
    /** Duration of this animation. */
    get duration(): number;
    /** Number of tracks in this animation. */
    get trackCount(): number;
    /**
     * Clone this animation retargeted to a new set of objects.
     *
     * The clone shares most of the data with the original and is therefore
     * light-weight.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * If retargetting to {@link Skin}, the join names will be used to determine a mapping
     * from the previous skin to the new skin. The source skin will be retrieved from
     * the first track in the animation that targets a joint.
     *
     * @param newTargets New targets per track. Expected to have
     *      {@link Animation#trackCount} elements or to be a {@link Skin}.
     * @returns The retargeted clone of this animation.
     */
    retarget(newTargets: $Object[] | Skin): Animation;
}
/**
 * Scene graph object.
 *
 * Node in the scene graph or "entity". Consists of transformation and a reference
 * to its parent object. Usually holds components and is accessible by components
 * through {@link Component#object}.
 *
 * Objects are stored in a data oriented manner inside WebAssembly memory. This class
 * is a JavaScript API wrapper around this memory for more convenient use in
 * components.
 *
 * Objects can be created and added to a scene through
 * {@link Scene#addObject} on the {@link scene|main scene}.
 */
declare class $Object {
    /**
     * Object index in the manager.
     */
    objectId: number;
    /**
     * @param o Object id to wrap
     */
    constructor(o: number);
    /**
     * Name of the object.
     *
     * Useful for identifying objects during debugging.
     */
    get name(): string;
    /**
     * Set the object's name.
     *
     * @param newName The new name to set.
     */
    set name(newName: string);
    /**
     * Parent of this object or {@link null} if parented to root.
     */
    get parent(): $Object | null;
    /**
     * Children of this object.
     */
    get children(): $Object[];
    /**
     * Reparent object to given object.
     *
     * @note Reparenting is not trivial and might have a noticeable performance impact.
     *
     * @param newParent New parent or {@link null} to parent to root
     */
    set parent(newParent: $Object | undefined | null);
    /** Reset local transformation (translation, rotation and scaling) to identity. */
    resetTransform(): void;
    /** Reset local translation and rotation to identity */
    resetTranslationRotation(): void;
    /**
     * Reset local rotation, keep translation.
     * @note To reset both rotation and translation, prefer
     *       {@link resetTranslationRotation}.
     */
    resetRotation(): void;
    /**
     * Reset local translation, keep rotation.
     * @note To reset both rotation and translation, prefer
     *       {@link resetTranslationRotation}.
     */
    resetTranslation(): void;
    /** Reset local scaling to identity (``[1.0, 1.0, 1.0]``). */
    resetScaling(): void;
    /**
     * Translate object by a vector in the parent's space.
     * @param v Vector to translate by.
     */
    translate(v: Readonly<NumberArray>): void;
    /**
     * Translate object by a vector in object space.
     * @param v Vector to translate by.
     */
    translateObject(v: Readonly<NumberArray>): void;
    /**
     * Translate object by a vector in world space.
     * @param v Vector to translate by.
     */
    translateWorld(v: Readonly<NumberArray>): void;
    /**
     * Rotate around given axis by given angle (degrees) in local space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in degrees.
     *
     * @note If the object is translated the rotation will be around
     *     the parent. To rotate around the object origin, use
     *     {@link rotateAxisAngleDegObject}
     *
     * @see {@link rotateAxisAngleRad}
     */
    rotateAxisAngleDeg(a: Readonly<NumberArray>, d: number): void;
    /**
     * Rotate around given axis by given angle (radians) in local space.
     *
     * @param {number[]} a Vector representing the rotation axis.
     * @param {number} d Angle in radians.
     *
     * @note If the object is translated the rotation will be around
     *     the parent. To rotate around the object origin, use
     *     {@link rotateAxisAngleDegObject}
     *
     * @see {@link rotateAxisAngleDeg}
     */
    rotateAxisAngleRad(a: Readonly<NumberArray>, d: number): void;
    /**
     * Rotate around given axis by given angle (degrees) in object space.
     *
     * @param a Vector representing the rotation axis.
     * @param d Angle in degrees.
     *
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @see {@link rotateAxisAngleRadObject}
     */
    rotateAxisAngleDegObject(a: Readonly<NumberArray>, d: number): void;
    /**
     * Rotate around given axis by given angle (radians) in object space
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @param a Vector representing the rotation axis
     * @param d Angle in degrees
     *
     * @see {@link rotateAxisAngleDegObject}
     */
    rotateAxisAngleRadObject(a: Readonly<NumberArray>, d: number): void;
    /**
     * Rotate by a quaternion.
     *
     * @param q the Quaternion to rotate by.
     */
    rotate(q: Readonly<NumberArray>): void;
    /**
     * Rotate by a quaternion in object space.
     *
     * Equivalent to prepending a rotation quaternion to the object's
     * local transformation.
     *
     * @param q the Quaternion to rotate by.
     */
    rotateObject(q: Readonly<NumberArray>): void;
    /**
     * Scale object by a vector in object space.
     *
     * @param v Vector to scale by.
     */
    scale(v: Readonly<NumberArray>): void;
    /** Local / object space transformation. */
    get transformLocal(): Float32Array;
    /**
     * Set local transform.
     *
     * @param t Local space transformation.
     *
     * @since 0.8.5
     */
    set transformLocal(t: Readonly<NumberArray>);
    /**
     * Compute local / object space translation from transformation.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getTranslationLocal<T extends NumberArray>(out: T): T;
    /**
     * Compute world space translation from transformation.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getTranslationWorld<T extends NumberArray>(out: T): T;
    /**
     * Set local / object space translation.
     *
     * Concatenates a new translation dual quaternion onto the existing rotation.
     *
     * @param v New local translation array/vector, expected to have at least 3 elements.
     */
    setTranslationLocal(v: Readonly<NumberArray>): void;
    /**
     * Set world space translation.
     *
     * Applies the inverse parent transform with a new translation dual quaternion
     * which is concatenated onto the existing rotation.
     *
     * @param v New world translation array/vector, expected to have at least 3 elements.
     */
    setTranslationWorld(v: Readonly<NumberArray>): void;
    /**
     * Global / world space transformation.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     */
    get transformWorld(): Float32Array;
    /**
     * Set world transform.
     *
     * @param t Global / world space transformation.
     *
     * @since 0.8.5
     */
    set transformWorld(t: Readonly<NumberArray>);
    /** Local / object space scaling. */
    get scalingLocal(): Float32Array;
    /**
     * Set scaling local.
     *
     * @param s Global / world space transformation.
     *
     * @since 0.8.7
     */
    set scalingLocal(s: Readonly<NumberArray>);
    /**
     * Global / world space scaling.
     *
     * May recompute transformations of the hierarchy of this object,
     * if they were changed by JavaScript components this frame.
     */
    get scalingWorld(): Float32Array;
    /**
     * Set scaling world.
     *
     * @param t Global / world space transformation.
     *
     * @since 0.8.7
     */
    set scalingWorld(s: Readonly<NumberArray>);
    /**
     * Local space rotation.
     *
     * @since 0.8.7
     */
    get rotationLocal(): Float32Array;
    /**
     * Global / world space rotation
     *
     * @since 0.8.7
     */
    get rotationWorld(): Float32Array;
    /**
     * Set rotation local
     *
     * @param r Local space rotation
     *
     * @since 0.8.7
     */
    set rotationLocal(r: Readonly<NumberArray>);
    /**
     * Set rotation world.
     *
     * @param {number} r Global / world space rotation.
     *
     * @since 0.8.7
     */
    set rotationWorld(r: Readonly<NumberArray>);
    /**
     * Compute the object's forward facing world space vector.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getForward<T extends NumberArray>(out: T): T;
    /**
     * Compute the object's up facing world space vector.
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getUp<T extends NumberArray>(out: T): T;
    /**
     * Compute the object's right facing world space vector/
     *
     * @param out Destination array/vector, expected to have at least 3 elements.
     * @return The `out` parameter.
     */
    getRight<T extends NumberArray>(out: T): T;
    /**
     * Transform a vector by this object's world transform.
     *
     * @param out Out point
     * @param v Point to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorWorld<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a vector by this object's local transform
     *
     * @param out Out point
     * @param v Point to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorLocal<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a point by this object's world transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointWorld<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform a point by this object's local transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointLocal<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform a vector by this object's inverse world transform.
     *
     * @param {number[]} out Out point.
     * @param {number[]} v Vector to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorInverseWorld<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a point by this object's inverse local transform.
     *
     * @param out Out point
     * @param v Vector to transform, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformVectorInverseLocal<T extends NumberArray>(out: T, v?: NumberArray): T;
    /**
     * Transform a point by this object's inverse world transform.
     *
     * @param out Out point.
     * @param v Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointInverseWorld<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform a point by this object's inverse local transform.
     *
     * @param out Out point.
     * @param p Point to transform, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    transformPointInverseLocal<T extends NumberArray>(out: T, p?: NumberArray): T;
    /**
     * Transform an object space dual quaternion into world space.
     *
     * @param out Out transformation.
     * @param q Local space transformation, default `out`.
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toWorldSpaceTransform<T extends NumberArray>(out: T, q?: NumberArray): T;
    /**
     * Transform a world space dual quaternion into local space
     *
     * @param {number[]} out Out transformation
     * @param {number[]} q World space transformation, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toLocalSpaceTransform<T extends NumberArray>(out: T, q?: NumberArray): T;
    /**
     * Transform a world space dual quaternion into object space
     *
     * @param out Out transformation.
     * @param q World space transformation, default `out`
     * @return The `out` parameter.
     *
     * @since 0.8.7
     */
    toObjectSpaceTransform<T extends NumberArray>(out: T, q?: NumberArray): T;
    /**
     * Turn towards / look at target.
     *
     * @param v Target vector to turn towards.
     * @param up Up vector of this object, default `[0, 1, 0]`.
     */
    lookAt(v: NumberArray, up?: NumberArray): void;
    /** Destroy the object with all of its components and remove it from the scene */
    destroy(): void;
    /**
     * Mark transformation dirty.
     *
     * Causes an eventual recalculation of {@link transformWorld}, either
     * on next {@link getTranslationWorld}, {@link transformWorld} or
     * {@link scalingWorld} or the beginning of next frame, whichever
     * happens first.
     */
    setDirty(): void;
    /**
     * Disable/enable all components of this object.
     *
     * @param b New state for the components.
     *
     * @since 0.8.5
     */
    set active(b: boolean);
    /** @overload */
    getComponent(type: 'collision', index?: number): CollisionComponent | null;
    /** @overload */
    getComponent(type: 'text', index?: number): TextComponent | null;
    /** @overload */
    getComponent(type: 'view', index?: number): ViewComponent | null;
    /** @overload */
    getComponent(type: 'mesh', index?: number): MeshComponent | null;
    /** @overload */
    getComponent(type: 'input', index?: number): InputComponent | null;
    /** @overload */
    getComponent(type: 'light', index?: number): LightComponent | null;
    /** @overload */
    getComponent(type: 'animation', index?: number): AnimationComponent | null;
    /** @overload */
    getComponent(type: 'physx', index?: number): PhysXComponent | null;
    /** @overload */
    getComponent(typeOrClass: string, index?: number): Component | null;
    /** @overload */
    getComponent<T extends Component>(typeOrClass: ComponentConstructor<T>, index?: number): T | null;
    /**
     * @param typeOrClass Type name, pass a falsey value (`undefined` or {@link null}) to retrieve all.
     *     It's also possible to give a class definition. In this case, the method will use the `class.TypeName` field to
     *     find the components.
     * @returns All components of given type attached to this object.
     *
     * @note As this function is non-trivial, avoid using it in `update()` repeatedly,
     *      but rather store its result in `init()` or `start()`
     * @warning This method will currently return at most 341 components.
     */
    getComponents<T extends Component>(typeOrClass?: string | ComponentConstructor<T> | null): T[];
    /**
     * Add component of given type to the object.
     *
     * You can use this function to clone components, see the example below.
     *
     * ```js
     *  // Clone existing component (since 0.8.10)
     *  let original = this.object.getComponent('mesh');
     *  otherObject.addComponent('mesh', original);
     *  // Create component from parameters
     *  this.object.addComponent('mesh', {
     *      mesh: someMesh,
     *      material: someMaterial,
     *  });
     * ```
     *
     * @param typeOrClass Typename to create a component of. Can be native or
     *     custom JavaScript component type. It's also possible to give a class definition.
     *     In this case, the method will use the `class.TypeName` field.
     * @param params Parameters to initialize properties of the new component,
     *      can be another component to copy properties from.
     *
     * @returns {?(Component|CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} The component or {@link null} if the type was not found
     */
    addComponent<T extends Component>(typeOrClass: ComponentConstructor<T> | string, params: Record<string, any>): any;
    /**
     * Whether given object's transformation has changed.
     */
    get changed(): boolean;
    /**
     * Checks equality by comparing whether the wrapped native component ids
     * and component manager types are equal.
     *
     * @param otherObject Object to check equality with.
     * @returns Whether this object equals the given object.
     */
    equals(otherObject?: $Object): boolean;
    /**
     * Used internally.
     *
     * @param type The type
     * @return The component type
     */
    static _typeIndexFor(type: string): number;
    /**
     * Used internally.
     *
     * @param typeIndex The type index
     * @return The name as a string
     */
    static _typeNameFor(typeIndex: number): string;
}
/**
 * Wrapper around a native skin data.
 */
export declare class Skin {
    /**
     * Index of the skin in the manager.
     * @hidden
     */
    _index: number;
    constructor(index: number);
    /** Amount of joints in this skin. */
    get jointCount(): number;
    /** Joints object ids for this skin */
    get jointIds(): Uint16Array;
    /**
     * Dual quaternions in a flat array of size 8 times {@link jointCount}.
     *
     * Inverse bind transforms of the skin.
     */
    get inverseBindTransforms(): Float32Array;
    /**
     * Vectors in a flat array of size 3 times {@link jointCount}.
     *
     * Inverse bind scalings of the skin.
     */
    get inverseBindScalings(): Float32Array;
}
export { $Object as Object };
/**
 * Ray hit.
 *
 * Result of a {@link Scene.rayCast}.
 *
 * @note this class wraps internal engine data and should only be created internally.
 */
export declare class RayHit {
    /** Pointer to the memory heap. */
    private _ptr;
    /**
     * @param ptr Pointer to the ray hits memory.
     */
    constructor(ptr: number);
    /** Array of ray hit locations. */
    get locations(): Float32Array[];
    /** Array of ray hit normals (only when using {@link Physics#rayCast}. */
    get normals(): Float32Array[];
    /**
     * Prefer these to recalculating the distance from locations.
     *
     * Distances of array hits to ray origin.
     */
    get distances(): Float32Array;
    /** Hit objects */
    get objects(): ($Object | null)[];
    /** Number of hits (max 4) */
    get hitCount(): number;
}
declare class math {
    /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.
     *
     * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.
     *
     * Whether a quaternion or vector3 interpolation is intended is determined by
     * length of `a`.
     *
     * @param out Array to write result to.
     * @param a First tangent/handle.
     * @param b First point or quaternion.
     * @param c Second point or quaternion.
     * @param d Second handle.
     * @param f Interpolation factor in [0; 1].
     * @returns The `out` parameter.
     *
     * @since 0.8.6
     */
    static cubicHermite<T extends NumberArray>(out: T, a: Readonly<NumberArray>, b: Readonly<NumberArray>, c: Readonly<NumberArray>, d: Readonly<NumberArray>, f: number): T;
}
export { math };
/**
 * Check if a given value is a native string or a `String` instance.
 *
 * @param value The value to check.
 * @returns `true` if the `value` has type string literal or `String`, `false` otherwise.
 */
export declare function isString(value: unknown): unknown;
/**
 * @param objectId Object ID to wrap
 *
 * @returns Wrapped object
 * @note This is used for internal purposes
 *
 * @hidden
 */
export declare function _wrapObject(objectId: number): $Object;
/**
 * Retrieves a component instance if it exists, or create and cache
 * a new one.
 *
 * @param type component type name
 * @param {number} componentType Component manager index
 * @param {number} componentId Component id in the manager
 *
 * @returns JavaScript instance wrapping the native component
 *
 * @hidden
 */
export declare function _wrapComponent(type: string, componentType: number, componentId: number): any;
